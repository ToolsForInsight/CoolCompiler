/*
 *  The scanner definition for COOL.
 */

import java_cup.runtime.Symbol;

%%

%{

/*  Stuff enclosed in %{ %} is copied verbatim to the lexer class
 *  definition, all the extra variables/functions you want to use in the
 *  lexer actions should go here.  Don't remove or modify anything that
 *  was there initially.  */

    // Max size of string constants
    // initial
    static int MAX_STR_CONST = 1025;

    // For assembling string constants
    StringBuffer string_buf = new StringBuffer();

    private int curr_lineno = 1;
    int get_curr_lineno() {
	return curr_lineno;
    }

    private AbstractSymbol filename;

    void set_filename(String fname) {
	filename = AbstractTable.stringtable.addString(fname);
    }

    AbstractSymbol curr_filename() {
	return filename;
    }
%}

%init{

/*  Stuff enclosed in %init{ %init} is copied verbatim to the lexer
 *  class constructor, all the extra initialization you want to do should
 *  go here.  Don't remove or modify anything that was there initially. */

    // empty for now
%init}

%state STRING

%eofval{

/*  Stuff enclosed in %eofval{ %eofval} specifies java code that is
 *  executed when end-of-file is reached.  If you use multiple lexical
 *  states and want to do something special if an EOF is encountered in
 *  one of those states, place your code in the switch statement.
 *  Ultimately, you should return the EOF symbol, or your lexer won't
 *  work.  */

    switch(yy_lexical_state) {
    case YYINITIAL:
	/* nothing special to do in the initial state */
	break;
	/* If necessary, add code for other states here, e.g:
	   case COMMENT:
	   ...
	   break;
	*/
    case STRING:
      break;
    }
    return new Symbol(TokenConstants.EOF);
%eofval}

%class CoolLexer
%cup
%notunix
%char
%line

%%

<YYINITIAL>[0-9]+               { return new Symbol(TokenConstants.INT_CONST, AbstractTable.inttable.addString(yytext())); }          

<YYINITIAL>[a-zA-Z][a-zA-Z_0-9]* { String token = yytext();
                                  
				  if (token.equalsIgnoreCase("CLASS")) {
				    return new Symbol(TokenConstants.CLASS); 
                                  }
			          else if (token.equalsIgnoreCase("ELSE")) {
				    return new Symbol(TokenConstants.ELSE); 
				  }
                                  else if (token.equalsIgnoreCase("FI")) {
				    return new Symbol(TokenConstants.FI); 
				  }
                                  else if (token.equalsIgnoreCase("IF")) {
				    return new Symbol(TokenConstants.IF); 
				  }
                                  else if (token.equalsIgnoreCase("IN")) {
				    return new Symbol(TokenConstants.IN); 
			          }
                                  else if (token.equalsIgnoreCase("INHERITS")) {
				    return new Symbol(TokenConstants.INHERITS); 
				  }
                                  else if (token.equalsIgnoreCase("ISVOID")) {
				    return new Symbol(TokenConstants.ISVOID); 
				  }
                                  else if (token.equalsIgnoreCase("LET")) {
				    return new Symbol(TokenConstants.LET); 
				  }
				  else if (token.equalsIgnoreCase("LOOP")) {
				    return new Symbol(TokenConstants.LOOP); 
				  }
                                  else if (token.equalsIgnoreCase("POOL")) {
				    return new Symbol(TokenConstants.POOL); 
				  }
                                  else if (token.equalsIgnoreCase("THEN")) {
				    return new Symbol(TokenConstants.THEN); 
				  }
				  else if (token.equalsIgnoreCase("WHILE")) {
				    return new Symbol(TokenConstants.WHILE); 
				  }
                                  else if (token.equalsIgnoreCase("CASE")) {
				    return new Symbol(TokenConstants.CASE); 
				  }
                                  else if (token.equalsIgnoreCase("ESAC")) {
				    return new Symbol(TokenConstants.ESAC); 
				  }
                                  else if (token.equalsIgnoreCase("NEW")) {
				    return new Symbol(TokenConstants.NEW); 
				  }
				  else if (token.equalsIgnoreCase("OF")) {
				    return new Symbol(TokenConstants.OF); 
				  }
				  else if (token.equalsIgnoreCase("NOT")) {
				    return new Symbol(TokenConstants.NOT); 
				  } 			
		                  else if (java.lang.Character.isLowerCase(token.charAt(0))) {
                                    if (token.toLowerCase().equals("true") ||
                                        token.toLowerCase().equals("false")) {
                                      return new Symbol(TokenConstants.BOOL_CONST, AbstractTable.stringtable.addString(token.toLowerCase()));
                                    }
                                    else {
				      return new Symbol(TokenConstants.OBJECTID, AbstractTable.idtable.addString(token));
                                    }
				  }
				  else {
				    return new Symbol(TokenConstants.TYPEID, AbstractTable.idtable.addString(token));
				  }
                                }

<YYINITIAL>[-*/<=(){},~.@;:+]   { String token = yytext();

                                 if (token.equals("+")) {
				   return new Symbol(TokenConstants.PLUS); 
                                 }
			         else if (token.equals("-")) {
		         	    return new Symbol(TokenConstants.MINUS); 
				  }
                                  else if (token.equals("*")) {
				    return new Symbol(TokenConstants.MULT); 
				  }
                                  else if (token.equals("/")) {
				    return new Symbol(TokenConstants.DIV); 
				  }
                                  else if (token.equals("<")) {
				    return new Symbol(TokenConstants.LT); 
			          }
                                  else if (token.equals("=")) {
				    return new Symbol(TokenConstants.EQ); 
				  }
                                  else if (token.equals("(")) {
				    return new Symbol(TokenConstants.LPAREN); 
				  }
                                  else if (token.equals(")")) {
				    return new Symbol(TokenConstants.RPAREN); 
				  }
				  else if (token.equals("{")) {
				    return new Symbol(TokenConstants.LBRACE); 
				  }
                                  else if (token.equals("}")) {
				    return new Symbol(TokenConstants.RBRACE); 
				  }
                                  else if (token.equals(".")) {
				    return new Symbol(TokenConstants.DOT); 
				  }
				  else if (token.equals("~")) {
				    return new Symbol(TokenConstants.NEG); 
				  }		
		                  else if (token.equals(";")) {
				    return new Symbol(TokenConstants.SEMI); 
				  }
		                  else if (token.equals("@")) {
				    return new Symbol(TokenConstants.AT); 
				  }
		                  else if (token.equals(",")) {
				    return new Symbol(TokenConstants.COMMA); 
				  }
		                  else {
				    return new Symbol(TokenConstants.COLON); 
				  }
                                }

<YYINITIAL>=>                   { return new Symbol(TokenConstants.DARROW); }

<YYINITIAL>\<-                  { return new Symbol(TokenConstants.ASSIGN); }

<YYINITIAL>\<=                  { return new Symbol(TokenConstants.LE); }

<YYINITIAL>\"                   { yybegin(STRING); }

<STRING>([^\"\n]|(\\\\)*(\\\"))*(\\\\)*\n   { curr_lineno++;
                                            yybegin(YYINITIAL);
				            return new Symbol(TokenConstants.ERROR, AbstractTable.stringtable.addString("Unterminated string constant"));
                                          }

<STRING>([^\"\n]|(\\\\)*\\(\n)|(\\\"))*\"   { String string = yytext();
                                  string = string.substring(1, string.length()); 
  
                                  int charPos = 0;
                                  char currChar;
                                  char nextChar;
                                  char specialChar;

                                  while (charPos < string.length()) {

				    System.out.println("beginning charPos: " + charPos);
				    System.out.println("beginning string: " + string);
                                    currChar = string.charAt(charPos);

                                    if (currChar == '\\') {

                                      nextChar = string.charAt(charPos+1);

                                      if (nextChar == 'b' || nextChar == 'f' ||
                                          nextChar == 'n' || nextChar == 't') {

					switch (nextChar) {
					  case 'b': specialChar = '\b'; break; 
					  case 'n': specialChar = '\n'; break;
					  case 'f': specialChar = '\f'; break;
				  	  default: specialChar = '\t';
					}

				        string = string.substring(0, charPos) +
                                          specialChar +
					  string.substring(charPos+2, string.length());
                                      }
				      else {

                                        string = string.substring(0, charPos) +
                                          string.substring(charPos+1, string.length());
				      }
				    }
                                    else if (currChar == '\n') {
				      curr_lineno++;
				      return new Symbol(TokenConstants.ERROR, AbstractTable.stringtable.addString("Unterminated string constant"));
                                    }
				    else if(currChar == '\0') {
				      return new Symbol(TokenConstants.ERROR, AbstractTable.stringtable.addString("String with null character"));
				    }
                                    charPos++;
				    System.out.println("Ending string: " + string);
                                  }

				  return new Symbol(TokenConstants.STR_CONST, AbstractTable.stringtable.addString(string));
                                }

<YYINITIAL>--.*                 { String token = yytext();
				  String comment = token.substring(2, token.length()-1); }

<YYINITIAL>\*.*\*               { String token = yytext();
                                  String comment = token.substring(1, token.length()-2); }

<YYINITIAL>[" "\n\f\r\t\v]      { String token = yytext();
                                  String whitespaceType;

                                  if (token.equals(" ")) {
                                 
				      whitespaceType = " ";
				  }
				  else {
                                    
				      char escape = token.charAt(0);

                                      switch (escape) {
				          case '\n': 
					    whitespaceType = "\\n"; 
					    curr_lineno++;
					    break;
				          case '\f': whitespaceType = "\\f"; break;
				          case '\r': whitespaceType = "\\r"; break;
				          case '\t': whitespaceType = "\\t"; break;
                                          default: whitespaceType = "\\v";
                                      }
				  }
                               }

<YYINITIAL>.                   { return new Symbol(TokenConstants.ERROR, AbstractTable.stringtable.addString("LEXER BUG - UNMATCHED: " + yytext())); }
